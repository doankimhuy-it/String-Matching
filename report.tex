\documentclass[a4paper,11pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[utf8]{vntex}
\usepackage{blindtext, amsfonts, amsmath, listings, color}

\usepackage[dvipsnames]{xcolor}
\usepackage{tvietlistings}	

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{Ao}{rgb}{0.55, 0.71, 0.0}
% Phần biểu diễn
\lstset{frame=tb,
	language=TeX,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	basicstyle={\small\ttfamily},
	firstnumber=0,
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	captionpos=t,
	breakatwhitespace=true,
	tabsize=2,
	moredelim=**[is][\color{Ao}]{@}{@}
}

\title{TÌM KIẾM CHUỖI}
\author{
	Phan Lộc Sơn 19120033\\
	Đoàn Kim Huy \\
	Đỗ Hoài Nam \\
	Trần Anh Huy
}
\date{\today}
\begin{document}
	\maketitle
	\part*{TÌM KIẾM CHUỖI}
	
	\section{Xác định vấn đề}
	Tìm kiếm chuỗi hiện diện rất nhiều trong cuộc sống, ví dụ như: tìm tên thầy dạy DSA trong danh sách giảng viên,
	tìm tên trong bảng điểm,.. hoặc trong khoa học, như là tìm liệu cấu trúc ADN của virus này có trong virus khác hay không.

	Trong Tin học, các trình soạn thảo văn bản thường phải tìm kiếm (tất cả) các lần xuất hiện của một đoạn văn bản trong một văn bản dài. Thông thường văn bản được chỉnh sửa liên tục, và các phần văn bản cần tìm kiếm thì được nhập bởi người dùng. Việc phát minh ra các thuật toán tìm kiếm chuỗi hiệu quả đã giúp ích rất nhiều cho các bài toán kể trên.

	Bài toán tìm kiếm chuỗi thường được mô tả theo mô hình sau: \\
	Một chuỗi cần tìm kiếm S có dạng một chuỗi kí tự S[1..m], cần tìm chuỗi S trong một đoạn văn bản T[1..n], với m <= n. Đồng thời, tất cả các ký tự trong T và S đều thuộc về một tập hữu hạn các ký tự cho trước. Chuỗi S được gọi là xuất hiện bắt đầu từ vị trí p + 1 nếu thoả điều kiện: T[p + j] = S[j], với 1 <= j <= m.
	
	\vspace*{3mm}
	Có 3 thuật toán thường được dùng để tìm kiếm chuỗi:
	\begin{itemize}
	    \item Thuật toán Brute-force (vét cạn, hay còn gọi là thuật trâu)
	    \item Rabin - Karp
	    \item Knuth - Morris - Pratt
	\end{itemize}
	Chi tiết của từng thuật toán sẽ được trình bày bên dưới.

	\section{Một số thuật toán tìm kiếm chuỗi}
	\begin{enumerate}
		\item Brute-force 
		
			Giải thuật Brute-Force, hay còn gọi là vét cạn, 
			là thuật toán đơn giản nhất trong các thuật toán 
			tìm kiếm chuỗi con \textit{pattern} 
			trong chuỗi cha \textit{text}.

			Có thể giải thích đơn giản, giải thuật Brute-Force 
			so sánh lần lượt mỗi chuỗi con \textit{subtext} của \textit{text} 
			có cùng chiều dài với \textit{pattern} với \textit{pattern}, 
			nếu tìm được, trả về kết quả là vị trí được tìm thấy; khi không 
			tìm được kết quả mong muốn, trả về giá trị quy ước là không tìm thấy.

			Trong ví dụ sau, ta sẽ làm rõ cách hoạt động của giải thuật này:\\
			\textit{text} \hspace*{7mm}= \verb|Let them go!| \\
			\textit{pattern} \hspace*{0.1mm} = \verb|them| 
			% L
			\vspace*{4mm}
			\hrule
			\textcolor{red}{L}et them go!\\
			\textcolor{red}{t}hem

			% Le
			\vspace*{2mm}
			\hrule
			L\textcolor{red}{e}t them go!\\
			\textcolor{white}{L}\textcolor{red}{t}hem
			
			% Let
			\vspace*{2mm}
			\hrule
			Le\textcolor{ForestGreen}{t} them go!\\
			\textcolor{white}{Le}\textcolor{ForestGreen}{t}hem
			
			% Let 
			\vspace*{2mm}
			\hrule
			Le\textcolor{ForestGreen}{t}\textcolor{red}{\textvisiblespace}them go!\\
			\textcolor{white}{Le}\textcolor{ForestGreen}{t}\textcolor{red}{h}em

			% Let 
			\vspace*{2mm}
			\hrule
			Let\textcolor{red}{\textvisiblespace}them go!\\
			\textcolor{white}{Let}\textcolor{red}{t}hem
			
			% Let t
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{t}hem go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{t}hem

			% Let th
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{th}em go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{th}em
			
			% Let the
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{the}m go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{the}m
						
			% Let them
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{them} go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{them}
			\vspace*{2mm}
			\hrule

			Ta tìm thấy chuỗi pattern tại vị trí thứ 4!
			
			\vspace*{4mm}
			
			Từ ví dụ trên, ta thiết kế mã giả cho giải thuật Brute-Force:

			\begin{lstlisting}
			function: Brute-Force String Matching
			text: chuỗi cha 
			pattern: chuỗi cần tìm 
			subtext: 1 đoạn thân của chuỗi cha có cùng chiều dài với pattern.
			Trả về: vị trí tìm thấy đầu tiên hoặc -1 nếu không tìm thấy.
			
				vị trí tìm thấy = -1
				subtext = chuỗi con đầu text có độ dài bằng pattern
				while (chưa tìm thấy hoặc chưa tới cuối text)
					if (từng ký tự của subtext = pattern):
						trả về vị trí
					else:
						dịch chuyển chuỗi con subtext trong text sang phải 1 chữ cái
				Trả về: vị trí tìm thấy
					\end{lstlisting}
			
			Với chuỗi \textit{pattern} có độ dài là M, chuỗi \textit{text} có độ dài là N \\
			Phân tích độ phức tạp của thuật toán trong trường hợp xấu nhất:
			\begin{itemize}
				\item Mỗi lần so sánh với \textit{subtext}, \textit{pattern} phải so sánh nhiều nhất là M lần (trong trường hợp cả M - 1 ký tự đầu đều đúng).
				\item Có tất cả N - M + 1 chuỗi, vậy số chuỗi cần so sánh nhiều nhất là N - M + 1 \textit{subtext} như vậy (trong trường hợp N - M + 2 chuỗi \textit{subtext} đầu không trùng với \textit{pattern})
				
				$\to$ Cần M(N - M + 1) lần. Vì duyệt tới cuối mảng nên đây là trường hợp tìm thấy ở cuối mảng, hoặc không tìm thấy\\
				$\to$ Cận trên $O(MN)$ (vì N > N - M + 1). \\
				$\to$ Cấp phát bộ nhớ: 0.
			\end{itemize}

			Phân tích độ phức tạp của thuật toán trong trường hợp tốt nhất:
			\begin{itemize}
				\item Trong trường hợp tốt nhất, có thể thấy \textit{pattern} chính là \textit{subtext} đầu tiên của \textit{text}.
				\item Như vậy, chỉ cần tốn M lần so sánh các ký tự.
				
				$\to$ Cần M lần. \\
				$\to$ Cận trên $O(M)$. \\
				$\to$ Cấp phát bộ nhớ: 0.
			\end{itemize}

			Độ phức tạp của thuật toán trong trường hợp trung bình: $O(MN)$
			
			Đánh giá:
			\begin{itemize}
				\item Dễ hiểu, thuật toán này chỉ duyệt từ đầu đến cuối, so sánh tuần tự từng chuỗi con với chuỗi cần tìm kiếm.
				\item Không cần bước tiền xử lý (như các thuật toán được trình bày bên dưới).
				\item Độ phức tạp $O(MN)$. Không cần xin thêm bộ nhớ.
			\end{itemize}

		\item Rabin-Karp
		
			Thuật toán Rabin-Karp là một thuật toán được sử dụng để tìm kiếm
			chuỗi con \textit{pattern} trong chuỗi cha \textit{text} bằng cách sử dụng một hàm băm.

			Hàm băm là một hàm chuyển đổi mọi chuỗi thành giá trị số, giá trị này được gọi là mã băm của nó. Ví dụ, chúng ta có thể có hàm băm hash("hello")=5.

			Giống như Thuật toán Brute-Force, thuật toán Rabin-Karp cũng dịch \textit{pattern} 
			qua từng phần tử trong \textit{text} để so sánh.
			Nhưng sự khác biệt là thuật toán Rabin-Karp so khớp mã băm của \textit{pattern} 
			với mã băm của chuỗi con \textit{subtext} của \textit{text}, và nếu mã băm khớp thì thuật toán sẽ so sánh từng ký tự trong 2 chuỗi với nhau.

			Nếu mã băm được biểu diễn bằng số nguyên không quá 64 bits, độ phức tạp thời gian (time-complexity) 
			của việc so sánh \textit{pattern} có độ dài m với \textit{subtext} có cùng độ dài giảm từ O(m) xuống O(1).

			Tuy nhiên mọi thứ đều có hai mặt, vấn đề của hàm băm đó là mã băm của hai chuỗi khác nhau có thể bằng nhau. 
			Ví dụ xét hàm băm hash(S) tính mã băm của xâu S bằng cách cộng mã ASCII của các kí tự trong S: hash("abcd")=97+98+99+100=394, hàm băm này quá đơn giản và có khả năng gây trùng mã băm cao: hash("dcba")=100+99+98+97=394, nhưng "abcd" $\neq$ "dcba".

			Một hàm băm tốt thoả mãn các điều kiện sau:
			\begin{itemize}
				\item Tính toán nhanh.
				\item Xác suất trùng mã băm nhỏ.
			\end{itemize}

			Thuật toán Rabin-Karp xây dựng hàm băm với ý tuởng cơ số: xem mọi xâu như là một chuỗi số với một cơ số (base) nào đó. Hàm băm đuợc tính tương tự như việc ta chuyển một số nguyên về giá trị của nó, nếu là xâu kí tự thì có thể sử dụng mã ASCII (hoặc UNICODE). Một số ví dụ:
			\begin{itemize}
			\item base=10, hash("425")=4×102+2×101+5×100=425.
			\item base=26, kí tự là chữ cái từ a đến z: hash("abc")=97×262+98×261+99×260=68219.
			\end{itemize}
			Để tránh tràn số thì kết quả trên đuợc chia lấy dư cho một số q, thường được chọn là một số nguyên tố lớn. Nếu gọi tập các kí tự được sử dụng trong chuỗi là $\sum$ thì base thừờng được chọn sao cho base=|$\sum$| hoặc là một số nguyên tố lớn.

			Độ phức tạp thời gian để tính mã băm của chuỗi độ dài k mất O(k). Khi hiện thực thuật toán, ta sẽ "trượt" \textit{pattern} có độ dài m trên \textit{text} từ vị trí 0 đến n-m để so sánh mã băm. Rolling hash là hàm băm có thể tính mã băm $h_i$ của \textit{text}[i... i+m-1] dựa trên mã băm $h_{i-1}$ của \textit{text}[(i-1)... (i+m)] chỉ trong thời gian O(1) thay vì tính lại trong thời gian O(m), từ đó tăng tính hiệu quả.

			$h_i=(base\times(h_{i-1}-base^{m-1}\times\textit{text}[i-1])+\textit{text}[i+m-1]) \% q$

			Trong ví dụ sau, ta sẽ làm rõ cách hoạt động của giải thuật này:\\
			Để đơn giản, ta chọn tập các kí tự được sử dụng trong chuỗi là \{a, b, c, d, e, f, g, h, i, j\} ứng với giá trị số lần lượt là \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\} và base=10, q=13.\\
			\textit{text} \hspace*{6mm}= abccddaefg\\
			\textit{pattern} \hspace*{0.3mm}= cdd\\
			Mã băm của \textit{pattern}: hash("cdd")=$(3\times10^2+4\times10^1+4\times10^0) \% 13=344 \% 13=6$

			\vspace*{4mm}
			\hrule
			\textcolor{ForestGreen}{abc}cddaefg \hspace*{0.6cm} // hash("abc")=$(1\times10^2+2\times10^1+3\times10^0) \% 13=123 \% 13=6$\\
			\textcolor{ForestGreen}{cdd} \hspace*{1.8cm} // Vì mã băm của \textit{subtext} "abc" và \textit{pattern} bằng nhau \\
		\hspace*{2.5cm} // nên thuật toán so sánh từng ký tự của chúng.\\
		\hspace*{2.5cm} // Do "abc"$\neq$\textit{pattern} nên dịch \textit{pattern} qua phải 1 phần tử để tiếp tục tìm kiếm.

			\vspace*{2mm}
			\hrule
			a\textcolor{ForestGreen}{bcc}ddaefg \hspace*{0.6cm} // hash("bcc")=$(10\times(123-10^2\times1)+3)\%13=233\%13=12$\\
			\textcolor{white}{a}\textcolor{ForestGreen}{cdd} \hspace*{1.6cm} // Vì mã băm của \textit{subtext} "bcc" và \textit{pattern} khác nhau \\
		\hspace*{2.5cm} // nên dịch \textit{pattern} qua phải 1 phần tử để tiếp tục tìm kiếm.

			\vspace*{2mm}
			\hrule
			ab\textcolor{ForestGreen}{ccd}daefg \hspace*{0.6cm} // hash("ccd")=$(10\times(233-10^2\times2)+4)\%13=334\%13=9$\\
			\textcolor{white}{aa}\textcolor{ForestGreen}{cdd} \hspace*{1.4cm} // Vì mã băm của \textit{subtext} "ccd" và \textit{pattern} khác nhau \\
		\hspace*{2.5cm} // nên dịch \textit{pattern} qua phải 1 phần tử để tiếp tục tìm kiếm.

			\vspace*{2mm}
			\hrule
			abc\textcolor{ForestGreen}{cdd}aefg \hspace*{0.6cm} // hash("cdd")=$(10\times(334-10^2\times3)+4)\%13=344\%13=6$\\
			\textcolor{white}{aaa}\textcolor{ForestGreen}{cdd} \hspace*{1.2cm} // Vì mã băm của \textit{subtext} "ccd" và \textit{pattern} bằng nhau \\
		\hspace*{2.5cm} // nên thuật toán so sánh từng ký tự của chúng.\\
		\hspace*{2.5cm} // Do "abc"$=$\textit{pattern} nên chuỗi đã được tìm thấy.

		\vspace*{2mm}
		\hrule
		\vspace*{4mm}
		Từ ví dụ trên, ta thiết kế mã giả cho giải thuật Rabin-Karp:

			\begin{lstlisting}
			function: Rabin-Karp String Matching
			text: chuỗi cha 
			pattern: chuỗi cần tìm 
			subtext: 1 đoạn thân của chuỗi cha có cùng chiều dài với pattern.
			Trả về: vị trí tìm thấy đầu tiên hoặc -1 nếu không tìm thấy.
			
				n=chiều dài chuỗi text
				m=chiều dài chuỗi pattern
				Tính mã băm của pattern và chuỗi con đầu text có độ dài bằng pattern
				Dịch pattern từ vị trí 0, qua từng phần tử của text đến vị trí n-m
					Kiểm tra mã băm của subtext hiện tại và pattern
						Nếu bằng nhau, so sánh từng ký tự trong 2 chuỗi
							Nếu hoàn toàn giống nhau, trả về vị trí
					Tính mã băm của subtext tiếp theo, nếu âm cộng thêm một lượng q
				Nếu trong vòng lặp không tìm thấy pattern, ta đã duyệt hết text, trả về -1 báo kết quả không tìm thấy pattern trong text.
			\end{lstlisting}

			Với chuỗi \textit{pattern} có độ dài là M, chuỗi \textit{text} có độ dài là N: \\
			Phân tích độ phức tạp của thuật toán:

				Trong quá trình tiền xử lý, để tính mã băm cho \textit{pattern} cần duyệt qua M phần tử, tương tự với \textit{subtext} đầu tiên \textit{text}, vậy độ phức tạp là $O(M+M) \in O(M)$.

				Trường hợp tốt nhất, có thể thấy \textit{pattern} chính là \textit{subtext} đầu tiên của \textit{text}, khi đó chỉ cần tốn M lần so sánh các ký tự, kết hợp với quá trình tiền xử lý nên độ phức tạp là $O(M+M) \in O(M)$.

				Trường hợp xấu nhất:
			\begin{itemize}
				\item Mỗi lần so sánh với \textit{subtext}, \textit{pattern} phải so sánh nhiều nhất là M lần (trong trường hợp mã băm bằng nhau và cả M - 1 ký tự đầu đều đúng).
				\item Có tất cả N - M + 1 chuỗi, vậy số chuỗi cần so sánh nhiều nhất là N - M + 1 \textit{subtext} như vậy (trong trường hợp chuỗi cần tìm nằm cuối, N - M + 2 chuỗi \textit{subext} đầu không trùng với \textit{pattern}).
				
				$\to$ Cần nhiều nhất M(N - M + 1) lần so sánh. Vì duyệt tới cuối chuỗi nên đây là trường hợp tìm thấy ở cuối hoặc không tìm thấy và xảy ra trùng mã băm ở tất cả lần so sánh trước đó.\\
				$\to$ Cận trên $O(MN)$ (vì N > N - M + 1). 
				
				Trường hợp trung bình: $O(N+M) \in O(M)$
			\end{itemize}
				Do trong quá trình tìm kiếm có thực hiện tính toán và lưu mã băm nên chi phí bộ nhớ là hằng số $O(1)$.
			Đánh giá:
			\begin{itemize}
				\item Mặc dù trong trường hợp xấu nhất độ phức tạp là $O(MN)$ không tốt hơn giải thuật Brute-Force, nhưng giải thuật Rabin-Karp hoạt động tốt hơn nhiều trong trường hợp trung bình và thực tế.
				\item Có bước tiền xử lý với độ phức tạp $O(M)$ trước khi bắt đầu tìm kiếm.
				\item Độ phức tạp $O(MN)$. Chi phí bộ nhớ $O(1)$.
			\end{itemize}
		\item Knuth-Morris-Pratt
		
			Giải thuật Knuth-Morris-Pratt, về cơ bản cũng giống như thuật toán Brute-Force, 
			tuy nhiên, chỉ khác ở chỗ, Brute-Forch khi so sánh \textit{pattern} và \textit{subtext}, Brute-Force so sánh toàn bộ 
			các ký tự của chúng lại từ đầu, còn Knuth-Morris-Pratt, từ lần so sánh trước, sẽ quyết định có so sánh pattern với \textit{subtext} kế tiếp không, 
			và nếu không sẽ nhảy bao nhiêu bước đến \textit{subtext} khác. 
			(đã biết được chúng giống nhau), từ đó tiết kiệm được chi phí giải bài toán.

			Để dễ hiểu, ta xét 1 ví dụ như sau: 
			
			\textit{text} \hspace*{6mm}= ababcababd\\
			\textit{pattern} \hspace*{0.1mm}= ababd
			
			% L
			\vspace*{4mm}
			\hrule
			\textcolor{ForestGreen}{a}babcababd\\
			\textcolor{ForestGreen}{a}babd \hspace*{1.8cm} // So sánh như Brute-Force

			% Le
			\vspace*{2mm}
			\hrule
			\textcolor{ForestGreen}{ab}abcababd\\
			\textcolor{ForestGreen}{ab}abd
			
			% Le
			\vspace*{2mm}
			\hrule
			\textcolor{ForestGreen}{aba}bcababd\\
			\textcolor{ForestGreen}{aba}bd

			% Le
			\vspace*{2mm}
			\hrule
			\textcolor{ForestGreen}{abab}cababd\\
			\textcolor{ForestGreen}{abab}d

			% Let 
			\vspace*{2mm}
			\hrule
			\textcolor{ForestGreen}{abab}\textcolor{red}{c}ababd\\
			\textcolor{ForestGreen}{abab}\textcolor{red}{d}			\hspace*{1.8cm} // ta thấy ký tự thứ 5 không đúng, nên ta sẽ tìm chuỗi con tiếp theo để so sánh. \\
																	\hspace*{2.9cm} // vả lại ta/máy tính cũng thấy rằng có 4 ký tự đầu của pattern trùng với subtext \\
																	\hspace*{2.9cm} // Trong 4 ký tự đó (abab), có có \textbf{2 ký tự đầu} giống \textbf{2 ký tự cuối} \\
																	\hspace*{2.9cm} // Như vậy, lần tiếp theo ta nên so sánh pattern với chuỗi ab\textbf{abcab}abd 
																	
			\vspace*{2mm}
			\hrule
			a\textcolor{red}{bab}cabdabd\\
			\textcolor{white}{a}\textcolor{red}{aba}bd 			\hspace*{1.6cm} // Để ý rằng ta sẽ so sánh với chuỗi ab\textbf{abcab}abd (nhảy 2 bước so với hiện tại) mà \\
																							\hspace*{2.9cm} // không phải là a\textbf{babca}babd, vì subtext của bước so sánh này luôn không trùng\\
																							\hspace*{2.9cm} //  pattern, giả sử điều ngược lại, pattern[1, 4] = text[2, 6] vì chuỗi dài nhất để chuỗi \\
																							\hspace*{2.9cm} // đầu pattern[1, 4] và chuỗi cuối pattern[2, 4] giống nhau là 2 (ab, lớn nhất),  \\
																							\hspace*{2.9cm} // Lưu ý rằng ta lấy pattern[1, 4] để tìm chuỗi chung là vì nó là phần đã được so sánh \\
																							\hspace*{2.9cm} // đúng ở lượt trước, và ta có nhu cầu tái sử dụng các phép so sánh đúng này! \\
																							\hspace*{2.9cm} // Ngoài ra, chuỗi cuối ta chỉ lấy của pattern[2, 4] vì bước tiếp theo ta phải nhảy \\
																							\hspace*{2.9cm} // sang phải (nếu lấy pattern[1, 4] mà cả 4 ký tự giống nhau thì bước kế tiếp  \\
																							\hspace*{2.9cm} // ta nhảy về vị trí đang đứng, ở giải thuật này) \\
																							\hspace*{2.9cm} // Ta có: pattern[1, 3] = text[2, 4], mà text[2, 4] = pattern[2, 4] (lượt so sánh trước) \\
																							\hspace*{2.9cm} // như vậy là: pattern[1, 3] = pattern[2, 4], tức là có chuỗi độ dài 3 vừa là chuỗi đầu 
																							\hspace*{2.9cm} // vừa là chuỗi cuối của pattern[1, 4] (vô lý vì 2 là số lớn nhất).

			% Le
			\vspace*{2mm}
			\hrule
			ab\textcolor{ForestGreen}{ab}\textcolor{red}{c}ababd\\
			\textcolor{white}{ab}\textcolor{ForestGreen}{ab}\textcolor{red}{a}bd 		\hspace*{1.4cm} // Ta so sánh ký tự thứ 3 trở đi (vì ta/máy tính biết đã có 2 ký tự đầu tiên là  \\
																						\hspace*{2.9cm} // giống nhau rồi!), ở bước này, phép so sánh là sai. \\
																						\hspace*{2.9cm} // Vị trí sai là 3,  ta thấy không có chuỗi chung vừa là \\
																						\hspace*{2.9cm} // chuỗi đầu và vừa là chuỗi cuối của pattern[1, 2], nên ta nhảy 1 bước sang phải.
			\vspace*{2mm}
			\hrule
			aba\textcolor{red}{b}cababd\\
			\textcolor{white}{aba}\textcolor{red}{a}babd 

			\vspace*{2mm}
			\hrule
			abab\textcolor{red}{c}ababd\\
			\textcolor{white}{abab}\textcolor{red}{a}babd 		\hspace*{1.3cm} // Tiếp tục so sánh như Brute-Force

			\vspace*{2mm}
			\hrule
			ababc\textcolor{ForestGreen}{a}babd\\
			\textcolor{white}{ababc}\textcolor{ForestGreen}{a}babd 

			\vspace*{2mm}
			\hrule
			ababc\textcolor{ForestGreen}{ab}abd\\
			\textcolor{white}{ababc}\textcolor{ForestGreen}{ab}abd 

			\vspace*{2mm}
			\hrule
			ababc\textcolor{ForestGreen}{aba}bd\\
			\textcolor{white}{ababc}\textcolor{ForestGreen}{aba}bd 

			\vspace*{2mm}
			\hrule
			ababc\textcolor{ForestGreen}{abab}d\\
			\textcolor{white}{ababc}\textcolor{ForestGreen}{abab}d 

			\vspace*{2mm}
			\hrule
			ababc\textcolor{ForestGreen}{ababd}\\
			\textcolor{white}{ababc}\textcolor{ForestGreen}{ababd} \hspace*{1.2cm} // Ok, tìm thấy rồi!
			
			\vspace*{2mm}
			\hrule			
		
			Note: Với string là chuỗi có độ dài n. và j là số nguyên dương 0 < j < n + 1\\
			Chuỗi đầu: Prefix, có dạng prefix[] = string[1, j], chuỗi cuối: Suffix, có dạng Suffix[] = string[j, n].
				
			Từ ví dụ trên, ta tìm cách thiết kế ý tưởng của KMP để tìm chuỗi 1 cách tổng quát:
			\begin{itemize}
				\item Ta thấy rằng, để KMP tìm cách nhảy hiệu quả, cần phải xử lý trước pattern, tìm chuỗi chung vừa là chuỗi đầu, vừa là chuỗi cuối của pattern.
				Bước này gọi là bước tìm Failure Function, tại mỗi vị trí j trong pattern (0 < j < len(pattern) + 1), tìm độ dài lớn nhất của chuỗi chung và lưu vào mảng $f[]$ để lưu trữ.
				\item Khi đang so sánh pattern và subtext, ta có thể gặp các trường hợp (0 < i <= len(subtext)): \\
				1. Nếu pattern[i] = subtext[i], tăng thêm i để so sánh ký tự kế tiếp. \\
				2. Nếu pattern[i] $\neq$ subtext[i], và i = 1, tức là ký tự đầu của chúng khác nhau, đơn giản là chỉ cần nhảy subtext sang bên phải 1 bước.\\
				3. Nếu pattern[i] $\neq$ subtext[i], và i > 1, tức là đã có 1 lượng i - 1 ký tự ở trước đã được so sánh đúng, bây giờ là đến lúc cần dùng mảng $f$ đã tính trước ở bên trên, ta lấy f[i - 1] 
				(chính là độ dài lớn nhất của chuỗi chung của pattern[1, i - 1]) và ta sẽ nhảy subtext 1 lượng min((i - 1) - f[i - 1], 1) để chuẩn bị cho lượt so sánh kế tiếp.
			\end{itemize}
			
			Từ ý tưởng trên, ta xây dựng mã giả cho thuật toán KMP:

			\begin{lstlisting}
			function: Build Failure Function
			pattern: chuỗi cần tìm 
			Trả về: Mảng f lưu độ dài lớn nhất f[i] của chuỗi chung prefix và suffix của pattern[1, i].

				f[] = 0 để lưu mảng trả về
				fpre = 0;   // lưu f[i - 1] trong vòng lặp bên dưới
				i = 2;		@// Ta chỉ tính f[2] trở đi, f[1] luôn bằng 0@
				while (i <= n)		
					Nếu pattern[i] == pattern[f[i - 1] + 1]
						fpre++
						f[i] = fpre	@// tận dụng kết i - 1 kết quả so sánh của f[i - 1], ta chỉ cần so sánh 1 ký tự.@
						i++
					Nếu pattern[i] != pattern[f[i - 1] + 1] và f[i - 1] = 0
						@// Tức là suffix và prefix là chuỗi có độ dài f[i - 1] + 1 có ký tự cuối không giống@
						@// -> f[i] = 0@
						f[i] = 0
						i++
					Nếu pattern[i] != pattern[f[i - 1] + 1] và f[i - 1] > 0
						@// Trường hợp này, có thể f[i] = f[i - 1]@
						@// Ta sẽ tận dụng pattern[1, f[i- 1]] = pattern[i - f[i-1], i]@
						@// Và f[f[j]] (độ dài này lớn nhất là j - 1)@
						@// Ví dụ AAABAAAA khi xét i = 8, ta lợi dụng chuỗi [AA]ABAAAA = A[AA]BAAAA và [AAA]BAAAA = AAAB[AAA]A@
						@// Suy ra được [AA]ABAAAA = A[AA]BAAAA = AAABA[AA]A@
						@// Như thế chỉ cần xét ký tự AA[A]BAAAA và AAABAAA[A] để xác định f[i]@
						fpre = f[fpre]
				Trả về: f[]

			function: KMP String Matching
			text: chuỗi cha 
			pattern: chuỗi cần tìm 
			Trả về: vị trí tìm thấy đầu tiên hoặc -1 nếu không tìm thấy.

				i = 1; j = 1; (i đánh dấu vị trí đang duyệt trong text, j đánh dấu vị trí đang duyệt trong pattern)
				while (i < len(text) - len(pattern))
					Nếu pattern[j] == text[i]
						Tiếp tục i++ và j++ và so sánh
							Nếu j = len(pattern) trả về đã tìm thấy pattern tại vị trí i - j.
					Nếu pattern[j] != text[i] và j == 1
						i = i + 1  @//Chuyển nhảy subtext sang phải 1 đơn vị @
					Nếu pattern[j] != text[i] và j > 1
						j = f[i] và tiếp tục so sánh text[i] và pattern[j] @// sau khi gán j = f[i] (giảm j) thì ta đã cố tình dịch chuyển subtext đang so sánh sang subtext khác!@
				Nếu trong vòng lặp không tìm thấy pattern, ta đã duyệt hết text, trả về -1 báo kết quả không tìm thấy pattern trong text.
					\end{lstlisting}
			
			Với chuỗi \textit{pattern} có độ dài là M, chuỗi \textit{text} có độ dài là N \\
			Phân tích độ phức tạp của thuật toán trong trường hợp xấu nhất:
			\begin{itemize}
				\item Trong quá trình tiền xử lý (tính hàm Failure Function), trong vòng while chỉ tốn nhiều nhất 1 - 2 lần để tính f[i], vậy độ 
				phức tạp là $O(M)$
				\item Trong quá trình so sánh, mỗi lần, ta hoặc sẽ tăng i lên 1 đơn vị, hoặc sẽ giảm j ít nhất 1 đơn vị (trong trường hợp dịch j), nghĩa là tăng k lên 1 đơn vị, k = i - j < N.
				Vậy tổng cộng trong vòng lặp có thể lặp < 2n lần (N lần tăng i, ít hơn N lần tăng k), như vậy độ phức tạp là $O(2N)$.\\
				$\to$ Độ phức tạp $O(M + N)$.\\
				$\to$ Cấp phát bộ nhớ: $O(M)$.
			\end{itemize}

			Phân tích độ phức tạp của thuật toán trong trường hợp tốt nhất:
			\begin{itemize}
				\item Trong trường hợp tốt nhất, có thể thấy \textit{pattern} chính là \textit{subtext} đầu tiên của \textit{text}.
				\item Như vậy, chỉ cần tốn M lần so sánh các ký tự. Ngoài ra còn tốn thêm chi phí tính Failure Function $O(M)$.\\
				$\to$ Cận trên $O(M)$. \\
				$\to$ Cấp phát bộ nhớ: $O(M)$.
			\end{itemize}

			Độ phức tạp của thuật toán trong trường hợp trung bình:
			\begin{itemize}
				\item Cận trên $O(N + M)$.
				\item Cấp phát bộ nhớ: $O(M)$.
			\end{itemize}

			Đánh giá:
			\begin{itemize}
				\item Nhanh, chi phí tuyến tính.
				\item Phải xử lý trước khi tìm kiếm thực sự.
				\item Độ phức tạp $O(M + N)$. Chi phí bộ nhớ $O(M)$.
			\end{itemize}

			
	\end{enumerate}
	
	\part*{TÌM KIẾM CHUỖI TRONG TIN HỌC}
	\Large {Ví dụ về Crossword game}
	\setcounter{section}{0}
	\section{Hướng giải Crossword game}

	Trong phần này, nhóm chúng tôi quyết định sẽ sử dụng thuật toán KMP để làm giải thuật tìm kiếm chuỗi, bởi vì giải thuật này có vẻ nhanh hơn 2 giải thuật còn lại với thời gian $O(M + N)$.

	Thuật toán chính của chương trình là đọc mảng chữ cái vào mảng \textbf{table} để tìm theo hàng ngang, và tạo mảng \textbf{Transpose\_table} bằng cách chuyển vị mảng \textbf{table} để tìm theo hàng dọc.

	Tìm bằng thuật toán KMP, hàng ngang trước và hàng dọc sau, nếu tìm thấy, in ra vị trí tìm thấy, nếu không, in ra NF.
	\section{Một số mẫu kiểm tra lời giải}
	
\end{document}
