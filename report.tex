\documentclass[a4paper,11pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[utf8]{vntex}
\usepackage{blindtext, amsfonts, amsmath, listings, color}

\usepackage[dvipsnames]{xcolor}
\usepackage{tvietlistings}	

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{Ao}{rgb}{0.55, 0.71, 0.0}
% Phần biểu diễn
\lstset{frame=tb,
	language=TeX,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	basicstyle={\small\ttfamily},
	firstnumber=0,
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	captionpos=t,
	breakatwhitespace=true,
	tabsize=2,
	moredelim=**[is][\color{red}]{@}{@},
	moredelim=**[is][\color{Ao}]{!}{!},
}

\title{Sections and Chapters}
\author{Gubert Farnsworth}
\date{\today}
\begin{document}
	\maketitle
	\part*{STRING MATCHING}
	
	\section{String Matching Problem}
	Tìm kiếm chuỗi hiện diện trong cuộc sống, ví dụ như: tìm tên thầy dạy DSA trong danh sách giảng viên,
	tìm tên trong bảng điểm,.. hoặc trong khoa học, như là tìm liệu cấu trúc ADN của virus này có trong virus khác hay không,

	\section{String Matching Algorithms}
	\begin{enumerate}
		\item Brute-force 
		
			Giải thuật Brute-Force, hay còn gọi là vét cạn, 
			là thuật toán đơn giản nhất trong các thuật toán 
			tìm kiếm chuỗi con \textit{pattern} 
			trong chuỗi cha \textit{text}.

			Có thể giải thích đơn giản, giải thuật Brute-Force 
			so sánh lần lượt mỗi chuỗi con \textit{subtext} của \textit{text} 
			có cùng chiều dài với \textit{pattern} với \textit{pattern}, 
			nếu tìm được, trả về kết quả là vị trí được tìm thấy; khi không 
			tìm được kết quả mong muốn, trả về giá trị quy ước là không tìm thấy.

			Trong ví dụ sau, ta sẽ làm rõ cách hoạt động của giải thuật này:\\
			\textit{text} \hspace*{7mm}= \verb|Let them go!| \\
			\textit{pattern} \hspace*{0.1mm} = \verb|them| 
			% L
			\vspace*{4mm}
			\hrule
			\textcolor{red}{L}et them go!\\
			\textcolor{red}{t}hem

			% Le
			\vspace*{2mm}
			\hrule
			L\textcolor{red}{e}t them go!\\
			\textcolor{white}{L}\textcolor{red}{t}hem
			
			% Let
			\vspace*{2mm}
			\hrule
			Le\textcolor{ForestGreen}{t} them go!\\
			\textcolor{white}{Le}\textcolor{ForestGreen}{t}hem
			
			% Let 
			\vspace*{2mm}
			\hrule
			Le\textcolor{ForestGreen}{t}\textcolor{red}{\textvisiblespace}them go!\\
			\textcolor{white}{Le}\textcolor{ForestGreen}{t}\textcolor{red}{h}em

			% Let 
			\vspace*{2mm}
			\hrule
			Let\textcolor{red}{\textvisiblespace}them go!\\
			\textcolor{white}{Let}\textcolor{red}{t}hem
			
			% Let t
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{t}hem go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{t}hem

			% Let th
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{th}em go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{th}em
			
			% Let the
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{the}m go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{the}m
						
			% Let them
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{them} go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{them}
			\vspace*{2mm}
			\hrule

			Ta tìm thấy chuỗi pattern tại vị trí thứ 4!
			
			Từ ví dụ trên, ta thiết kế mã giả cho giải thuật Brute-Force:

			\begin{lstlisting}
				vị trí tìm thấy = -1
				subtext = chuỗi con đầu text có độ dài bằng pattern
				while (chưa tìm thấy hoặc chưa tới cuối text)
					if (từng ký tự của subtext = pattern):
						trả về vị trí
					else:
						dịch chuyển chuỗi con subtext trong text sang phải 1 chữ cái
				Trả về: vị trí tìm thấy
					\end{lstlisting}
			
			Với chuỗi \textit{pattern} có độ dài là M, chuỗi \textit{text} có độ dài là N \\
			Phân tích độ phức tạp của thuật toán trong trường hợp xấu nhất:
			\begin{itemize}
				\item Mỗi lần so sánh với \textit{subtext}, \textit{pattern} phải so sánh nhiều nhất là M lần (trong trường hợp cả M - 1 ký tự đầu đều đúng).
				\item Có tất cả N - M + 1 chuỗi, vậy số chuỗi cần so sánh nhiều nhất là N - M + 1 \textit{subtext} như vậy (trong trường hợp N - M + 2 chuỗi \textit{subext} đầu không trùng với \textit{pattern})
				
				$\to$ Cần M(N - M + 1) lần. Vì duyệt tới cuối mảng nên đây là trường hợp tìm thấy ở cuối mảng, hoặc không tìm thấy\\
				$\to$ Cận trên $O(MN)$ (vì N > N - M + 1). \\
				$\to$ Cấp phát bộ nhớ: 0.
			\end{itemize}

			Phân tích độ phức tạp của thuật toán trong trường hợp tốt nhất:
			\begin{itemize}
				\item Trong trường hợp tốt nhất, có thể thấy \textit{pattern} chính là \textit{subtext} đầu tiên của \textit{text}.
				\item Như vậy, chỉ cần tốn M lần so sánh các ký tự.
				
				$\to$ Cần M lần. \\
				$\to$ Cận trên $O(M)$. \\
				$\to$ Cấp phát bộ nhớ: 0.
			\end{itemize}
			
			Đánh giá:
			\begin{itemize}
				\item Dễ hiểu, thuật toán này chỉ duyệt từ đầu đến cuối, so sánh tuần tự từng chuỗi con với chuỗi cần tìm kiếm.
				\item Không cần bước tiền xử lý (như các thuật toán được trình bày bên dưới).
				\item Độ phức tạp $O(MN)$. Không cần xin thêm bộ nhớ.
			\end{itemize}

		\subsection {Rabin-Karp}

			Thuật toán Rabin-Karp là một thuật toán được sử dụng để tìm kiếm
			chuỗi con \textit{pattern} trong chuỗi cha \textit{text} bằng cách sử dụng một hàm băm.

			Hàm băm là một hàm chuyển đổi mọi chuỗi thành giá trị số, giá trị này được gọi là mã băm của nó. Ví dụ, chúng ta có thể có hàm băm hash("hello")=5.

			Giống như Thuật toán Brute-Force, thuật toán Rabin-Karp cũng dịch \textit{pattern} 
			qua từng phần tử trong \textit{text} để so sánh.
			Nhưng sự khác biệt là thuật toán Rabin-Karp so khớp mã băm của \textit{pattern} 
			với mã băm của chuỗi con \textit{subtext} của \textit{text}, và nếu mã băm khớp thì thuật toán sẽ so sánh từng ký tự trong 2 chuỗi với nhau.

			Nếu mã băm được biểu diễn bằng số nguyên không quá 64 bits, độ phức tạp thời gian (time-complexity) 
			của việc so sánh \textit{pattern} có độ dài m với \textit{subtext} có cùng độ dài giảm từ O(m) xuống O(1).

			Tuy nhiên mọi thứ đều có hai mặt, vấn đề của hàm băm đó là mã băm của hai chuỗi khác nhau có thể bằng nhau. 
			Ví dụ xét hàm băm hash(S) tính mã băm của xâu S bằng cách cộng mã ASCII của các kí tự trong S: hash("abcd")=97+98+99+100=394, hàm băm này quá đơn giản và có khả năng gây trùng mã băm cao: hash("dcba")=100+99+98+97=394, nhưng "abcd" $\neq$ "dcba".

			Một hàm băm tốt thoả mãn các điều kiện sau:
			\begin{itemize}
				\item Tính toán nhanh.
				\item Xác suất trùng mã băm nhỏ.
			\end{itemize}

			Thuật toán Rabin-Karp xây dựng hàm băm với ý tuởng cơ số: xem mọi xâu như là một chuỗi số với một cơ số (base) nào đó. Hàm băm đuợc tính tương tự như việc ta chuyển một số nguyên về giá trị của nó, nếu là xâu kí tự thì có thể sử dụng mã ASCII (hoặc UNICODE). Một số ví dụ:
			\begin{itemize}
			\item base=10, hash("425")=4×102+2×101+5×100=425.
			\item base=26, kí tự là chữ cái từ a đến z: hash("abc")=97×262+98×261+99×260=68219.
			\end{itemize}
			Để tránh tràn số thì kết quả trên đuợc chia lấy dư cho một số q, thường được chọn là một số nguyên tố lớn. Nếu gọi tập các kí tự được sử dụng trong chuỗi là $\sum$ thì base thừờng được chọn sao cho base=|$\sum$| hoặc là một số nguyên tố lớn.

			Độ phức tạp thời gian để tính mã băm của chuỗi độ dài k mất O(k). Khi hiện thực thuật toán, ta sẽ "trượt" \textit{pattern} có độ dài m trên \textit{text} từ vị trí 0 đến n-m để so sánh mã băm. Rolling hash là hàm băm có thể tính mã băm $h_i$ của \textit{text}[i... i+m-1] dựa trên mã băm $h_{i-1}$ của \textit{text}[(i-1)... (i+m)] chỉ trong thời gian O(1) thay vì tính lại trong thời gian O(m), từ đó tăng tính hiệu quả.

			$h_i=(base\times(h_{i-1}-base^{m-1}\times\textit{text}[i-1])+\textit{text}[i+m-1]) \% q$

	\end{enumerate}
	
	\part*{PROGRAMING}
	\label{Crossword game}(abc)
	
	
	\setcounter{section}{0}
	\section{Introduce}
	\section{Example Test}
	
\end{document}
