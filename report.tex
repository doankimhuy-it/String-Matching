\documentclass[a4paper,11pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[utf8]{vntex}
\usepackage{blindtext, amsfonts, amsmath, listings, color}

\usepackage[dvipsnames]{xcolor}
\usepackage{tvietlistings}	

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{Ao}{rgb}{0.55, 0.71, 0.0}
% Phần biểu diễn
\lstset{frame=tb,
	language=TeX,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	basicstyle={\small\ttfamily},
	firstnumber=0,
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	captionpos=t,
	breakatwhitespace=true,
	tabsize=2,
	moredelim=**[is][\color{red}]{@}{@},
	moredelim=**[is][\color{Ao}]{!}{!},
}

\title{Sections and Chapters}
\author{Gubert Farnsworth}
\date{\today}
\begin{document}
	\maketitle
	\part*{STRING MATCHING}
	
	\section{String Matching Problem}
	Tìm kiếm chuỗi hiện diện trong cuộc sống, ví dụ như: tìm tên thầy dạy DSA trong danh sách giảng viên,
	tìm tên trong bảng điểm,.. hoặc trong khoa học, như là tìm liệu cấu trúc ADN của virus này có trong virus khác hay không,

	\section{String Matching Algorithms}
	\begin{enumerate}
		\item Brute-force 
		
			Giải thuật Brute-Force, hay còn gọi là vét cạn, 
			là thuật toán đơn giản nhất trong các thuật toán 
			tìm kiếm chuỗi con \textit{pattern} 
			trong chuỗi cha \textit{text}.

			Có thể giải thích đơn giản, giải thuật Brute-Force 
			so sánh lần lượt mỗi chuỗi con \textit{subtext} của \textit{text} 
			có cùng chiều dài với \textit{pattern} với \textit{pattern}, 
			nếu tìm được, trả về kết quả là vị trí được tìm thấy; khi không 
			tìm được kết quả mong muốn, trả về giá trị quy ước là không tìm thấy.

			Trong ví dụ sau, ta sẽ làm rõ cách hoạt động của giải thuật này:\\
			\textit{text} \hspace*{7mm}= \verb|Let them go!| \\
			\textit{pattern} \hspace*{0.1mm} = \verb|them| 
			% L
			\vspace*{4mm}
			\hrule
			\textcolor{red}{L}et them go!\\
			\textcolor{red}{t}hem

			% Le
			\vspace*{2mm}
			\hrule
			L\textcolor{red}{e}t them go!\\
			\textcolor{white}{L}\textcolor{red}{t}hem
			
			% Let
			\vspace*{2mm}
			\hrule
			Le\textcolor{ForestGreen}{t} them go!\\
			\textcolor{white}{Le}\textcolor{ForestGreen}{t}hem
			
			% Let 
			\vspace*{2mm}
			\hrule
			Le\textcolor{ForestGreen}{t}\textcolor{red}{\textvisiblespace}them go!\\
			\textcolor{white}{Le}\textcolor{ForestGreen}{t}\textcolor{red}{h}em

			% Let 
			\vspace*{2mm}
			\hrule
			Let\textcolor{red}{\textvisiblespace}them go!\\
			\textcolor{white}{Let}\textcolor{red}{t}hem
			
			% Let t
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{t}hem go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{t}hem

			% Let th
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{th}em go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{th}em
			
			% Let the
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{the}m go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{the}m
						
			% Let them
			\vspace*{2mm}
			\hrule
			Let \textcolor{ForestGreen}{them} go!\\
			\textcolor{white}{Let }\textcolor{ForestGreen}{them}
			\vspace*{2mm}
			\hrule

			Ta tìm thấy chuỗi pattern tại vị trí thứ 4!
			
			Từ ví dụ trên, ta thiết kế mã giả cho giải thuật Brute-Force:

			\begin{lstlisting}
				vị trí tìm thấy = -1
				subtext = chuỗi con đầu text có độ dài bằng pattern
				while (chưa tìm thấy hoặc chưa tới cuối text)
					if (từng ký tự của subtext = pattern):
						trả về vị trí
					else:
						dịch chuyển chuỗi con subtext trong text sang phải 1 chữ cái
				Trả về: vị trí tìm thấy
					\end{lstlisting}
			
			Với chuỗi \textit{pattern} có độ dài là M, chuỗi \textit{text} có độ dài là N \\
			Phân tích độ phức tạp của thuật toán trong trường hợp xấu nhất:
			\begin{itemize}
				\item Mỗi lần so sánh với \textit{subtext}, \textit{pattern} phải so sánh nhiều nhất là M lần (trong trường hợp cả M - 1 ký tự đầu đều đúng).
				\item Có tất cả N - M + 1 chuỗi, vậy số chuỗi cần so sánh nhiều nhất là N - M + 1 \textit{subtext} như vậy (trong trường hợp N - M + 2 chuỗi \textit{subext} đầu không trùng với \textit{pattern})
				
				$\to$ Cần M(N - M + 1) lần. Vì duyệt tới cuối mảng nên đây là trường hợp tìm thấy ở cuối mảng, hoặc không tìm thấy\\
				$\to$ Cận trên $O(MN)$ (vì N > N - M + 1). \\
				$\to$ Cấp phát bộ nhớ: 0.
			\end{itemize}

			Phân tích độ phức tạp của thuật toán trong trường hợp tốt nhất:
			\begin{itemize}
				\item Trong trường hợp tốt nhất, có thể thấy \textit{pattern} chính là \textit{subtext} đầu tiên của \textit{text}.
				\item Như vậy, chỉ cần tốn M lần so sánh các ký tự.
				
				$\to$ Cần M lần. \\
				$\to$ Cận trên $O(M)$. \\
				$\to$ Cấp phát bộ nhớ: 0.
			\end{itemize}
			
			Đánh giá:
			\begin{itemize}
				\item Dễ hiểu, thuật toán này chỉ duyệt từ đầu đến cuối, so sánh tuần tự từng chuỗi con với chuỗi cần tìm kiếm.
				\item Không cần bước tiền xử lý (như các thuật toán được trình bày bên dưới).
				\item Độ phức tạp $O(MN)$. Không cần xin thêm bộ nhớ.
			\end{itemize}

		\subsection {Rabin-Karp}

			Thuật toán Rabin-Karp là một thuật toán được sử dụng để tìm kiếm
			chuỗi con \textit{pattern} trong chuỗi cha \textit{text} bằng cách sử dụng một hàm băm.

			Hàm băm là một hàm chuyển đổi mọi chuỗi thành giá trị số, giá trị này được gọi là mã băm của nó. Ví dụ, chúng ta có thể có hàm băm hash("hello")=5.

			Giống như Thuật toán Brute-Force, thuật toán Rabin-Karp cũng dịch \textit{pattern} 
			qua từng phần tử trong \textit{text} để so sánh.
			Nhưng sự khác biệt là thuật toán Rabin-Karp so khớp mã băm của \textit{pattern} 
			với mã băm của chuỗi con \textit{subtext} của \textit{text}, và nếu mã băm khớp thì thuật toán sẽ so sánh từng ký tự trong 2 chuỗi với nhau.

			Nếu mã băm được biểu diễn bằng số nguyên không quá 64 bits, độ phức tạp thời gian (time-complexity) 
			của việc so sánh \textit{pattern} có độ dài m với \textit{subtext} có cùng độ dài giảm từ O(m) xuống O(1).

			Tuy nhiên mọi thứ đều có hai mặt, vấn đề của hàm băm đó là mã băm của hai chuỗi khác nhau có thể bằng nhau. 
			Ví dụ xét hàm băm hash(S) tính mã băm của xâu S bằng cách cộng mã ASCII của các kí tự trong S: hash("abcd")=97+98+99+100=394, hàm băm này quá đơn giản và có khả năng gây trùng mã băm cao: hash("dcba")=100+99+98+97=394, nhưng "abcd" $\neq$ "dcba".

			Một hàm băm tốt thoả mãn các điều kiện sau:
			\begin{itemize}
				\item Tính toán nhanh.
				\item Xác suất trùng mã băm nhỏ.
			\end{itemize}

			Thuật toán Rabin-Karp xây dựng hàm băm với ý tuởng cơ số: xem mọi xâu như là một chuỗi số với một cơ số (base) nào đó. Hàm băm đuợc tính tương tự như việc ta chuyển một số nguyên về giá trị của nó, nếu là xâu kí tự thì có thể sử dụng mã ASCII (hoặc UNICODE). Một số ví dụ:
			\begin{itemize}
			\item base=10, hash("425")=4×102+2×101+5×100=425.
			\item base=26, kí tự là chữ cái từ a đến z: hash("abc")=97×262+98×261+99×260=68219.
			\end{itemize}
			Để tránh tràn số thì kết quả trên đuợc chia lấy dư cho một số q, thường được chọn là một số nguyên tố lớn. Nếu gọi tập các kí tự được sử dụng trong chuỗi là $\sum$ thì base thừờng được chọn sao cho base=|$\sum$| hoặc là một số nguyên tố lớn.

			Độ phức tạp thời gian để tính mã băm của chuỗi độ dài k mất O(k). Khi hiện thực thuật toán, ta sẽ "trượt" \textit{pattern} có độ dài m trên \textit{text} từ vị trí 0 đến n-m để so sánh mã băm. Rolling hash là hàm băm có thể tính mã băm $h_i$ của \textit{text}[i... i+m-1] dựa trên mã băm $h_{i-1}$ của \textit{text}[(i-1)... (i+m)] chỉ trong thời gian O(1) thay vì tính lại trong thời gian O(m), từ đó tăng tính hiệu quả.

			$h_i=(base\times(h_{i-1}-base^{m-1}\times\textit{text}[i-1])+\textit{text}[i+m-1]) \% q$

			Trong ví dụ sau, ta sẽ làm rõ cách hoạt động của giải thuật này:\\
			Để đơn giản, ta chọn tập các kí tự được sử dụng trong chuỗi là \{a, b, c, d, e, f, g, h, i, j\} ứng với giá trị số lần lượt là \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\} và base=10, q=13.\\
			\textit{text} \hspace*{6mm}= abccddaefg\\
			\textit{pattern} \hspace*{0.3mm}= cdd\\
			Mã băm của \textit{pattern}: hash("cdd")=$(3\times10^2+4\times10^1+4\times10^0) \% 13=344 \% 13=6$

			\vspace*{4mm}
			\hrule
			\textcolor{ForestGreen}{abc}cddaefg \hspace*{0.6cm} // hash("abc")=$(1\times10^2+2\times10^1+3\times10^0) \% 13=123 \% 13=6$\\
			\textcolor{ForestGreen}{cdd} \hspace*{1.8cm} // Vì mã băm của \textit{subtext} "abc" và \textit{pattern} bằng nhau \\
		\hspace*{2.5cm} // nên thuật toán so sánh từng ký tự của chúng.\\
		\hspace*{2.5cm} // Do "abc"$\neq$\textit{pattern} nên dịch \textit{pattern} qua phải 1 phần tử để tiếp tục tìm kiếm.\\

			\vspace*{2mm}
			\hrule
			a\textcolor{ForestGreen}{bcc}ddaefg \hspace*{0.6cm} // hash("bcc")=$(10\times(123-10^2\times1)+3)\%13=233\%13=12$\\
			\textcolor{white}{a}\textcolor{ForestGreen}{cdd} \hspace*{1.6cm} // Vì mã băm của \textit{subtext} "bcc" và \textit{pattern} khác nhau \\
		\hspace*{2.5cm} // nên dịch \textit{pattern} qua phải 1 phần tử để tiếp tục tìm kiếm.\\

			\vspace*{2mm}
			\hrule
			ab\textcolor{ForestGreen}{ccd}daefg \hspace*{0.6cm} // hash("ccd")=$(10\times(233-10^2\times2)+4)\%13=334\%13=9$\\
			\textcolor{white}{aa}\textcolor{ForestGreen}{cdd} \hspace*{1.4cm} // Vì mã băm của \textit{subtext} "ccd" và \textit{pattern} khác nhau \\
		\hspace*{2.5cm} // nên dịch \textit{pattern} qua phải 1 phần tử để tiếp tục tìm kiếm.\\

			\vspace*{2mm}
			\hrule
			abc\textcolor{ForestGreen}{cdd}aefg \hspace*{0.6cm} // hash("cdd")=$(10\times(334-10^2\times3)+4)\%13=344\%13=6$\\
			\textcolor{white}{aaa}\textcolor{ForestGreen}{cdd} \hspace*{1.2cm} // Vì mã băm của \textit{subtext} "ccd" và \textit{pattern} bằng nhau \\
		\hspace*{2.5cm} // nên thuật toán so sánh từng ký tự của chúng.\\
		\hspace*{2.5cm} // Do "abc"$=$\textit{pattern} nên chuỗi đã được tìm thấy.\\

Từ ví dụ trên, ta thiết kế mã giả cho giải thuật Rabin-Karp:

			\begin{lstlisting}
			function: Rabin-Karp String Matching
			text: chuỗi cha 
			pattern: chuỗi cần tìm 
			subtext: 1 đoạn thân của chuỗi cha có cùng chiều dài với pattern.
			Trả về: vị trí tìm thấy đầu tiên hoặc -1 nếu không tìm thấy.
			
				n=chiều dài chuỗi text
				m=chiều dài chuỗi pattern
				Tính mã băm của pattern và chuỗi con đầu text có độ dài bằng pattern
				Dịch pattern từ vị trí 0, qua từng phần tử của text đến vị trí n-m
					Kiểm tra mã băm của subtext hiện tại và pattern
						Nếu bằng nhau, so sánh từng ký tự trong 2 chuỗi
							Nếu hoàn toàn giống nhau, trả về vị trí
					Tính mã băm của subtext tiếp theo, nếu âm cộng thêm một lượng q
				Nếu trong vòng lặp không tìm thấy pattern, ta đã duyệt hết text, trả về -1 báo kết quả không tìm thấy pattern trong text.
			\end{lstlisting}

			Với chuỗi \textit{pattern} có độ dài là M, chuỗi \textit{text} có độ dài là N: \\
			Phân tích độ phức tạp của thuật toán:

				Trong quá trình tiền xử lý, để tính mã băm cho \textit{pattern} cần duyệt qua M phần tử, tương tự với \textit{subtext} đầu tiên \textit{text}, vậy độ phức tạp là $O(M+M) \in O(M)$.

				Trường hợp tốt nhất, có thể thấy \textit{pattern} chính là \textit{subtext} đầu tiên của \textit{text}, khi đó chỉ cần tốn M lần so sánh các ký tự, kết hợp với quá trình tiền xử lý nên độ phức tạp là $O(M+M) \in O(M)$.

				Trường hợp xấu nhất:
			\begin{itemize}
				\item Mỗi lần so sánh với \textit{subtext}, \textit{pattern} phải so sánh nhiều nhất là M lần (trong trường hợp mã băm bằng nhau và cả M - 1 ký tự đầu đều đúng).
				\item Có tất cả N - M + 1 chuỗi, vậy số chuỗi cần so sánh nhiều nhất là N - M + 1 \textit{subtext} như vậy (trong trường hợp chuỗi cần tìm nằm cuối, N - M + 2 chuỗi \textit{subext} đầu không trùng với \textit{pattern}).
				
				$\to$ Cần nhiều nhất M(N - M + 1) lần so sánh. Vì duyệt tới cuối chuỗi nên đây là trường hợp tìm thấy ở cuối hoặc không tìm thấy và xảy ra trùng mã băm ở tất cả lần so sánh trước đó.\\
				$\to$ Cận trên $O(MN)$ (vì N > N - M + 1). \\
			\end{itemize}
				Do trong quá trình tìm kiếm có thực hiện tính toán và lưu mã băm nên chi phí bộ nhớ là hằng số $O(1)$.
			Đánh giá:
			\begin{itemize}
				\item Mặc dù trong trường hợp xấu nhất độ phức tạp là $O(MN)$ không tốt hơn giải thuật Brute-Force, nhưng giải thuật Rabin-Karp hoạt động tốt hơn nhiều trong trường hợp trung bình và thực tế.
				\item Có bước tiền xử lý với độ phức tạp $O(M)$ trước khi bắt đầu tìm kiếm.
				\item Độ phức tạp $O(MN)$. Chi phí bộ nhớ $O(1)$.
			\end{itemize}
	\end{enumerate}
	
	\part*{PROGRAMING}
	\label{Crossword game}(abc)
	
	
	\setcounter{section}{0}
	\section{Introduce}
	\section{Example Test}
	
\end{document}
